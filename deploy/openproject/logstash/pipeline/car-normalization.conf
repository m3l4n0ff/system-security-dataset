input {
  beats {
    port => 5044
  }
}

filter {
  # ============================================================
  # STEP 1: Container name normalization
  # Filebeat may not always populate [container][name].
  # Fall back to Docker Compose service label.
  # ============================================================
  if ![container][name] and [container][labels][com_docker_compose_service] {
    mutate {
      copy => { "[container][labels][com_docker_compose_service]" => "[container][name]" }
    }
  }

  # ============================================================
  # STEP 2: Extract experiment labels
  # Docker converts label dots to underscores (event.label -> event_label).
  # Filebeat JS already extracts these to top-level fields, but we
  # also copy from container.labels as a safety net.
  # ============================================================
  if [container][labels][event_label] {
    mutate {
      copy => { "[container][labels][event_label]" => "[event][label]" }
    }
  }

  if [container][labels][attack_technique] {
    mutate {
      copy => { "[container][labels][attack_technique]" => "[attack][technique]" }
    }
  }

  if [container][labels][attack_tactic] {
    mutate {
      copy => { "[container][labels][attack_tactic]" => "[attack][tactic]" }
    }
  }

  if [container][labels][experiment_id] {
    mutate {
      copy => { "[container][labels][experiment_id]" => "[experiment][id]" }
    }
  }

  if [container][labels][scenario_id] {
    mutate {
      copy => { "[container][labels][scenario_id]" => "[scenario][id]" }
    }
  }

  # Dataset category from label
  if [event][label] == "malicious" {
    mutate {
      add_field => { "[dataset][category]" => "attack" }
    }
  } else {
    mutate {
      add_field => { "[dataset][category]" => "normal" }
    }
  }

  # ============================================================
  # STEP 3: Parse Caddy (proxy) logs -> CAR fields + trace.id
  # ============================================================
  if [container][name] and [container][name] =~ /proxy|caddy/ {

    json {
      source => "message"
      target => "caddy"
      skip_on_invalid_json => true
    }

    if [caddy][logger] == "http.log.access" {

      mutate {
        add_field => {
          "[car][object]" => "http"
          "[car][timestamp]" => "%{@timestamp}"
        }
      }

      # HTTP method -> car.action (lowercased)
      if [caddy][request][method] {
        mutate {
          copy => { "[caddy][request][method]" => "[car][action]" }
        }
        mutate {
          lowercase => [ "[car][action]" ]
        }
      }

      # URL fields
      if [caddy][request][uri] {
        mutate {
          copy => { "[caddy][request][uri]" => "[car][url_remainder]" }
        }
      }

      if [caddy][request][host] {
        mutate {
          copy => { "[caddy][request][host]" => "[car][url_domain]" }
        }
      }

      if [caddy][request][uri] and [caddy][request][host] {
        mutate {
          add_field => {
            "[car][url_full]" => "http://%{[caddy][request][host]}%{[caddy][request][uri]}"
            "[car][url_scheme]" => "http"
          }
        }
      }

      # Response fields
      if [caddy][status] {
        mutate {
          copy => { "[caddy][status]" => "[car][response_status_code]" }
        }
      }

      if [caddy][size] {
        mutate {
          copy => { "[caddy][size]" => "[car][response_body_bytes]" }
        }
      }

      # Source IP
      if [caddy][request][remote_ip] {
        mutate {
          copy => { "[caddy][request][remote_ip]" => "[car][src_ip]" }
        }
      }

      # User-Agent
      if [caddy][request][headers][User-Agent][0] {
        mutate {
          copy => { "[caddy][request][headers][User-Agent][0]" => "[car][user_agent_full]" }
        }
      }

      # HTTP version
      if [caddy][request][proto] {
        mutate {
          copy => { "[caddy][request][proto]" => "[car][http_version]" }
        }
      }

      # Trace ID from X-Request-Id response header (set by Rails)
      if [caddy][resp_headers][X-Request-Id][0] {
        mutate {
          copy => { "[caddy][resp_headers][X-Request-Id][0]" => "[trace][id]" }
        }
      }
    }
  }

  # ============================================================
  # STEP 4: Parse Rails (web) logs -> CAR fields + trace.id
  # ============================================================
  if [container][name] and [container][name] =~ /web|openproject/ {

    # Parse Rails log format to extract request_id
    grok {
      match => {
        "message" => [
          "\w, \[%{TIMESTAMP_ISO8601:rails_ts} #%{NUMBER:rails_pid}\]%{SPACE}%{LOGLEVEL:rails_level}%{SPACE}-- : \[%{UUID:rails_request_id}\] %{GREEDYDATA:rails_rest}",
          "\w, \[%{TIMESTAMP_ISO8601:rails_ts} #%{NUMBER:rails_pid}\]%{SPACE}%{LOGLEVEL:rails_level}%{SPACE}-- : %{GREEDYDATA:rails_rest}",
          "\[%{NUMBER}\] %{GREEDYDATA:rails_rest}"
        ]
      }
      break_on_match => true
      tag_on_failure => ["_grok_rails_fail"]
    }

    # Trace ID from Rails request_id (same UUID as Caddy's X-Request-Id)
    if [rails_request_id] {
      mutate {
        copy => { "rails_request_id" => "[trace][id]" }
      }
    }

    # Parse HTTP request summary lines (method=GET path=/api/v3/projects ...)
    if [rails_rest] =~ /method=/ {
      grok {
        match => {
          "rails_rest" => "method=%{WORD:rails_method} path=%{NOTSPACE:rails_path}(?:.*status=%{NUMBER:rails_status})?"
        }
        tag_on_failure => ["_grok_rails_http_fail"]
      }

      if !("_grok_rails_http_fail" in [tags]) {
        mutate {
          add_field => {
            "[car][object]" => "http"
            "[car][url_remainder]" => "%{rails_path}"
            "[car][timestamp]" => "%{@timestamp}"
          }
        }
        mutate {
          add_field => { "[car][action]" => "%{rails_method}" }
        }
        mutate {
          lowercase => [ "[car][action]" ]
        }

        if [rails_status] {
          mutate {
            add_field => { "[car][response_status_code]" => "%{rails_status}" }
          }
        }
      }
    }

    # Authentication failure detection
    else if [rails_rest] =~ /Failed login/ or [message] =~ /Failed login/ {
      grok {
        match => {
          "message" => "Failed login for '%{DATA:auth_user}' from %{IP:auth_ip}"
        }
        tag_on_failure => ["_grok_auth_fail"]
      }

      mutate {
        add_field => {
          "[car][object]" => "authentication"
          "[car][action]" => "failure"
          "[car][auth_service]" => "openproject"
          "[car][failure_reason]" => "invalid_credentials"
          "[car][timestamp]" => "%{@timestamp}"
        }
        add_tag => ["authentication_failure"]
      }

      if [auth_user] {
        mutate { add_field => { "[car][user]" => "%{auth_user}" } }
      }
      if [auth_ip] {
        mutate { add_field => { "[car][src_ip]" => "%{auth_ip}" } }
      }
    }

    # Authentication success detection
    else if [rails_rest] =~ /Successful login/ or [message] =~ /Successful login/ {
      grok {
        match => {
          "message" => "Successful login for '%{DATA:auth_user}' from %{IP:auth_ip}"
        }
        tag_on_failure => ["_grok_auth_success_fail"]
      }

      mutate {
        add_field => {
          "[car][object]" => "authentication"
          "[car][action]" => "success"
          "[car][auth_service]" => "openproject"
          "[car][timestamp]" => "%{@timestamp}"
        }
        add_tag => ["authentication_success"]
      }

      if [auth_user] {
        mutate { add_field => { "[car][user]" => "%{auth_user}" } }
      }
      if [auth_ip] {
        mutate { add_field => { "[car][src_ip]" => "%{auth_ip}" } }
      }
    }

    # Clean up temporary grok fields
    mutate {
      remove_field => ["rails_ts", "rails_pid", "rails_level", "rails_request_id", "rails_rest", "rails_method", "rails_path", "rails_status", "auth_user", "auth_ip"]
    }
  }

  # ============================================================
  # STEP 5: Service name for filtering/grouping
  # ============================================================
  if [container][name] {
    mutate {
      add_field => { "[service][name]" => "%{[container][name]}" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "openproject-car-%{+YYYY.MM.dd}"
  }
}
